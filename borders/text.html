<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>React in one file</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
html, body, #root { height: 100%; margin: 0; }
body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- React 18 (dev builds). Use *.production.min.js for prod. -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel (transpiles JSX in-browser). Remove in prod if you prebuild. -->
    <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>

    <!-- Your React code goes here -->
    <script type="text/babel">
      const {useMemo, useRef, useState} = React;

// =============================================================
// Text → Vector Outlines → Point Lists (Python‑ready)
// System/web font ONLY — no file handling. Vector-ish via marching squares
// on a rasterized alpha mask of the text. Tunable resolution.
// =============================================================

// ---------- Math / Utils ----------
const isNum = (v) => typeof v === 'number' && Number.isFinite(v);
function roundPts(pts, decimals) {
  const m = Math.pow(10, Math.max(0, (decimals|0)));
  return pts.map(p => ({ x: Math.round(p.x * m) / m, y: Math.round(p.y * m) / m }));
}
function perpendicularDistance(pt, a, b) {
  const dx = b.x - a.x, dy = b.y - a.y;
  if (dx === 0 && dy === 0) return Math.hypot(pt.x - a.x, pt.y - a.y);
  const t = ((pt.x - a.x) * dx + (pt.y - a.y) * dy) / (dx * dx + dy * dy);
  const proj = { x: a.x + t * dx, y: a.y + t * dy };
  return Math.hypot(pt.x - proj.x, pt.y - proj.y);
}
function rdp(points, epsilon) {
  if (!Array.isArray(points) || points.length <= 2) return Array.isArray(points) ? points.slice() : [];
  let dmax = 0, index = 0;
  for (let i = 1; i < points.length - 1; i++) {
    const d = perpendicularDistance(points[i], points[0], points[points.length - 1]);
    if (d > dmax) { dmax = d; index = i; }
  }
  if (dmax > epsilon) {
    const rec1 = rdp(points.slice(0, index + 1), epsilon);
    const rec2 = rdp(points.slice(index), epsilon);
    return rec1.slice(0, -1).concat(rec2);
  }
  return [points[0], points[points.length - 1]];
}

// ---------- Rasterize text to alpha ----------
function rasterizeTextToAlpha(text, fontFamily, fontSize, padding) {
  const pad = Math.max(0, padding|0);
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.font = `${fontSize}px ${fontFamily}`;
  ctx.textBaseline = 'alphabetic';
  const m = ctx.measureText(text);
  // metrics for height: use em ascent/descent if available
  const ascent = isNum(m.actualBoundingBoxAscent) ? m.actualBoundingBoxAscent : fontSize * 0.8;
  const descent = isNum(m.actualBoundingBoxDescent) ? m.actualBoundingBoxDescent : fontSize * 0.2;
  const width = Math.ceil(m.width) + pad * 2 + 4;
  const height = Math.ceil(ascent + descent) + pad * 2 + 4;
  canvas.width = width;
  canvas.height = height;

  ctx.clearRect(0, 0, width, height);
  ctx.font = `${fontSize}px ${fontFamily}`;
  ctx.textBaseline = 'alphabetic';
  ctx.fillStyle = '#000';
  // draw at (pad, pad + ascent) so baseline sits within box
  ctx.fillText(text, pad, pad + ascent);

  const img = ctx.getImageData(0, 0, width, height);
  // Return normalized alpha sampler
  const sample = (x, y) => {
    // clamp
    x = Math.max(0, Math.min(width - 1, x|0));
    y = Math.max(0, Math.min(height - 1, y|0));
    const i = (y * width + x) * 4;
    return img.data[i + 3] / 255; // 0..1
  };
  return { width, height, sample };
}

// ---------- Marching Squares (segments) ----------
function msSegments({ width, height, sample }, grid, iso = 0.5) {
  const gs = Math.max(1, grid|0);
  const segs = [];
  const nx = Math.floor(width / gs) + 1;
  const ny = Math.floor(height / gs) + 1;

  const val = (ix, iy) => sample(ix * gs, iy * gs);
  const interp = (x0, y0, v0, x1, y1, v1) => {
    const dv = v1 - v0;
    const t = Math.abs(dv) < 1e-6 ? 0.5 : (iso - v0) / dv;
    const tclamp = Math.max(0, Math.min(1, t));
    return { x: x0 + (x1 - x0) * tclamp, y: y0 + (y1 - y0) * tclamp };
  };

  for (let iy = 0; iy < ny - 1; iy++) {
    for (let ix = 0; ix < nx - 1; ix++) {
      const x0 = ix * gs, y0 = iy * gs, x1 = (ix + 1) * gs, y1 = (iy + 1) * gs;
      const vTL = val(ix, iy);
      const vTR = val(ix + 1, iy);
      const vBR = val(ix + 1, iy + 1);
      const vBL = val(ix, iy + 1);

      const tl = vTL >= iso ? 1 : 0;
      const tr = vTR >= iso ? 1 : 0;
      const br = vBR >= iso ? 1 : 0;
      const bl = vBL >= iso ? 1 : 0;
      const code = (tl << 3) | (tr << 2) | (br << 1) | bl;
      if (code === 0 || code === 15) continue;

      const Ptop = () => interp(x0, y0, vTL, x1, y0, vTR);
      const Pright = () => interp(x1, y0, vTR, x1, y1, vBR);
      const Pbottom = () => interp(x0, y1, vBL, x1, y1, vBR);
      const Pleft = () => interp(x0, y0, vTL, x0, y1, vBL);

      const pushSeg = (a, b) => segs.push({ a, b });

      switch (code) {
        case 1: pushSeg(Pleft(), Pbottom()); break;            // 0001
        case 2: pushSeg(Pbottom(), Pright()); break;           // 0010
        case 3: pushSeg(Pleft(), Pright()); break;             // 0011
        case 4: pushSeg(Ptop(), Pright()); break;              // 0100
        case 5: pushSeg(Ptop(), Pleft()); pushSeg(Pright(), Pbottom()); break;  // 0101 ambiguous
        case 6: pushSeg(Ptop(), Pbottom()); break;             // 0110
        case 7: pushSeg(Pleft(), Ptop()); break;               // 0111
        case 8: pushSeg(Pleft(), Ptop()); break;               // 1000
        case 9: pushSeg(Ptop(), Pbottom()); break;             // 1001
        case 10: pushSeg(Ptop(), Pright()); pushSeg(Pbottom(), Pleft()); break; // 1010 ambiguous
        case 11: pushSeg(Ptop(), Pright()); break;             // 1011
        case 12: pushSeg(Pleft(), Pright()); break;            // 1100
        case 13: pushSeg(Pbottom(), Pright()); break;          // 1101
        case 14: pushSeg(Pleft(), Pbottom()); break;           // 1110
      }
    }
  }
  return segs;
}

// ---------- Stitch segments → polylines ----------
function stitchSegments(segments, keyDecimals = 3) {
  const key = (p) => `${p.x.toFixed(keyDecimals)},${p.y.toFixed(keyDecimals)}`;
  const map = new Map();
  segments.forEach((s, idx) => {
    const kA = key(s.a), kB = key(s.b);
    if (!map.has(kA)) map.set(kA, []);
    if (!map.has(kB)) map.set(kB, []);
    map.get(kA).push({ idx, end: 'a' });
    map.get(kB).push({ idx, end: 'b' });
  });
  const used = new Set();
  const polylines = [];

  for (let i = 0; i < segments.length; i++) {
    if (used.has(i)) continue;
    let seg = segments[i];
    used.add(i);
    const poly = [seg.a, seg.b];
    // extend forward from tail
    let tail = seg.b;
    while (true) {
      const k = key(tail);
      const candidates = (map.get(k) || []).filter(e => !used.has(e.idx));
      if (!candidates.length) break;
      const c = candidates[0];
      used.add(c.idx);
      const s = segments[c.idx];
      const next = (Math.abs(s.a.x - tail.x) < 1e-6 && Math.abs(s.a.y - tail.y) < 1e-6) ? s.b : s.a;
      poly.push(next);
      tail = next;
      if (Math.abs(poly[0].x - tail.x) < 1e-6 && Math.abs(poly[0].y - tail.y) < 1e-6) break; // closed
    }
    // try extend from head (optional)
    let head = poly[0];
    while (true) {
      const k = key(head);
      const candidates = (map.get(k) || []).filter(e => !used.has(e.idx));
      if (!candidates.length) break;
      const c = candidates[0];
      used.add(c.idx);
      const s = segments[c.idx];
      const next = (Math.abs(s.a.x - head.x) < 1e-6 && Math.abs(s.a.y - head.y) < 1e-6) ? s.b : s.a;
      poly.unshift(next);
      head = next;
    }
    polylines.push(poly);
  }
  return polylines;
}

// ---------- Full pipeline: text → contours ----------
function textToContoursMS(text, fontFamily, fontSize, grid, iso) {
  const pad = 8;
  const ras = rasterizeTextToAlpha(text, fontFamily, fontSize, pad);
  const segs = msSegments(ras, grid, iso);
  let polys = stitchSegments(segs);
  // dedupe trivial tiny polylines
  polys = polys.filter(p => p.length > 2);
  return { width: ras.width, height: ras.height, contours: polys };
}

// ---------- SVG / Python helpers ----------
function contoursToSvgPath(contours, closeIfLoop = true) {
  return contours.map(poly => {
    if (!poly.length) return '';
    const [f, ...rest] = poly;
    const cmds = [`M ${f.x} ${f.y}`, ...rest.map(p => `L ${p.x} ${p.y}`)];
    if (closeIfLoop && (Math.abs(f.x - poly[poly.length-1].x) < 1e-6 && Math.abs(f.y - poly[poly.length-1].y) < 1e-6)) cmds.push('Z');
    return cmds.join(' ');
  }).join(' ');
}
function contoursToPlainArray(contours, decimals) {
  return contours.map(poly => roundPts(poly, decimals).map(p => [p.x, p.y]));
}

function TextToPointsApp() {
  const [text, setText] = useState("Hello");
  const [fontFamily, setFontFamily] = useState("system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif");
  const [fontSize, setFontSize] = useState(120);
  const [grid, setGrid] = useState(2); // sampling grid (px)
  const [iso, setIso] = useState(0.5); // alpha threshold 0..1
  const [epsilon, setEpsilon] = useState(2.0); // simplification
  const [decimals, setDecimals] = useState(1);
  const [strokeWidth, setStrokeWidth] = useState(1);
  const [groupAs, setGroupAs] = useState("flat");
  const textAreaRef = useRef(null);
  const [testReport, setTestReport] = useState(null);

  const result = useMemo(() => {
    if (!text) return { glyphs: [], width: 0, height: 0, viewBox: "0 0 1 1" };
    const { width, height, contours } = textToContoursMS(text, fontFamily, fontSize, grid, iso);
    // simplify
    const simplified = contours.map(poly => rdp(poly, epsilon));
    return { glyphs: [simplified], width, height, viewBox: `0 0 ${width} ${height}` };
  }, [text, fontFamily, fontSize, grid, iso, epsilon]);

  const pythonText = useMemo(() => {
    if (!result.glyphs.length) return "[]";
    const toArr = (contours) => contoursToPlainArray(contours, decimals);
    if (groupAs === 'glyphs') return JSON.stringify(result.glyphs.map(toArr));
    const flat = [].concat(...result.glyphs);
    return JSON.stringify(toArr(flat));
  }, [result, decimals, groupAs]);

  function copyPython() { try { navigator.clipboard.writeText(pythonText); } catch {} }

  // ---------- Self‑tests ----------
  function runTests() {
    const items = [];
    const eq = (a,b) => JSON.stringify(a) === JSON.stringify(b);
    const tryTest = (name, fn) => { try { fn(); items.push({ name, ok: true }); } catch (e) { items.push({ name, ok: false, err: String(e) }); } };

    // T1: roundPts rounding
    tryTest('roundPts()', ()=>{ const r=roundPts([{x:1.234,y:2.345}],1); if(r[0].x!==1.2||r[0].y!==2.3) throw new Error(JSON.stringify(r)); });
    // T2: rdp degenerate
    tryTest('rdp()', ()=>{ const pts=[{x:0,y:0},{x:1,y:0},{x:2,y:0}]; const out=rdp(pts,0.01); if(out.length<2) throw new Error(); });
    // T3: msSegments basic square grid
    tryTest('msSegments() square', ()=>{
      const fake = { width: 10, height: 10, sample:(x,y)=> (x>=2&&x<=8&&y>=2&&y<=8?1:0) };
      const segs = msSegments(fake, 2, 0.5);
      if (!Array.isArray(segs) || segs.length === 0) throw new Error('no segs');
    });
    // T4: stitchSegments makes loops
    tryTest('stitchSegments() connects', ()=>{
      const segs = [ {a:{x:0,y:0}, b:{x:1,y:0}}, {a:{x:1,y:0}, b:{x:1,y:1}}, {a:{x:1,y:1}, b:{x:0,y:1}}, {a:{x:0,y:1}, b:{x:0,y:0}} ];
      const polys = stitchSegments(segs);
      if (!(polys.length===1 && polys[0].length>=4)) throw new Error('bad poly');
    });

    setTestReport({ ok: items.every(t=>t.ok), items });
  }

  const totalContours = result.glyphs.reduce((a,g)=>a+g.length,0);
  const totalPoints = result.glyphs.reduce((a,g)=>a+g.reduce((s,c)=>s+c.length,0),0);

  return (
    <div className="min-h-screen bg-neutral-50 text-neutral-900 p-4">
      <div className="max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-5 gap-4">
        <div className="lg:col-span-2 space-y-3">
          <h1 className="text-2xl font-semibold">Text → Outlines → Points</h1>
          <p className="text-sm text-neutral-600">System/web font only. Outlines approximated via marching‑squares over an alpha raster. Coarse by default.</p>

          <label className="block">
            <span className="text-sm font-medium">Font family (CSS)</span>
            <input value={fontFamily} onChange={e=>setFontFamily(e.target.value)} className="mt-1 block w-full border rounded-lg p-2 bg-white" />
          </label>

          <label className="block">
            <span className="text-sm font-medium">Text</span>
            <input value={text} onChange={e=>setText(e.target.value)} className="mt-1 block w-full border rounded-lg p-2 bg-white" />
          </label>

          <div className="grid grid-cols-2 gap-3">
            <label className="block">
              <span className="text-sm font-medium">Font size (px)</span>
              <input type="number" value={fontSize} onChange={e=>setFontSize(parseFloat(e.target.value||'0'))} className="mt-1 w-full border rounded-lg p-2 bg-white" />
            </label>
            <label className="block">
              <span className="text-sm font-medium">Grid (px) — lower = sharper</span>
              <input type="number" min={1} value={grid} onChange={e=>setGrid(Math.max(1, parseInt(e.target.value||'1')))} className="mt-1 w-full border rounded-lg p-2 bg-white" />
            </label>
          </div>

          <label className="block">
            <span className="text-sm font-medium">Alpha threshold</span>
            <input type="range" min={0} max={1} step={0.01} value={iso} onChange={e=>setIso(parseFloat(e.target.value))} className="mt-2 w-full" />
            <div className="text-xs text-neutral-600">iso: {iso.toFixed(2)}</div>
          </label>

          <label className="block">
            <span className="text-sm font-medium">Simplify tolerance (px)</span>
            <input type="range" min={0} max={10} step={0.1} value={epsilon} onChange={e=>setEpsilon(parseFloat(e.target.value))} className="mt-2 w-full" />
            <div className="text-xs text-neutral-600">epsilon: {epsilon.toFixed(1)}</div>
          </label>

          <label className="block">
            <span className="text-sm font-medium">Decimal places</span>
            <input type="range" min={0} max={4} value={decimals} onChange={e=>setDecimals(parseInt(e.target.value))} className="mt-2 w-full" />
            <div className="text-xs text-neutral-600">decimals: {decimals}</div>
          </label>

          <label className="block">
            <span className="text-sm font-medium">Stroke width</span>
            <input type="number" value={strokeWidth} onChange={e=>setStrokeWidth(parseFloat(e.target.value||'1'))} className="mt-1 w-full border rounded-lg p-2 bg-white" />
          </label>

          <label className="block">
            <span className="text-sm font-medium">Output grouping</span>
            <select value={groupAs} onChange={e=>setGroupAs(e.target.value)} className="mt-1 block w-full border rounded-lg p-2 bg-white">
              <option value="glyphs">[glyph][contour][[x,y]]</option>
              <option value="flat">[contour][[x,y]]</option>
            </select>
          </label>

          <div className="flex gap-2 pt-2">
            <button onClick={copyPython} className="px-3 py-2 rounded-xl bg-neutral-900 text-white">Copy Python list</button>
            <div className="text-xs text-neutral-600 self-center">Contours: {totalContours} · Points: {totalPoints}</div>
          </div>

          <div className="pt-3">
            <button onClick={runTests} className="px-3 py-2 rounded-xl border">Run self-tests</button>
            {testReport && (
              <div className="mt-2 text-xs">
                <div className={testReport.ok?"text-green-700":"text-red-700"}>
                  {testReport.ok?"All tests passed":"Some tests failed"}
                </div>
                <ul className="mt-1 space-y-1">
                  {testReport.items.map((t,i)=>(
                    <li key={i} className={t.ok?"text-green-700":"text-red-700"}>
                      {t.ok?"✓":"✗"} {t.name}{!t.ok && ` — ${t.err}`}
                    </li>
                  ))}
                </ul>
              </div>
            )}
          </div>
        </div>

        <div className="lg:col-span-3 flex flex-col gap-3">
          <div className="rounded-2xl bg-white shadow p-3">
            <div className="w-full overflow-auto border rounded-xl p-2">
              {result.glyphs.length ? (
                <svg xmlns="http://www.w3.org/2000/svg" viewBox={result.viewBox} className="w-full h-[420px]">
                  <g fill="none" stroke="currentColor" strokeWidth={strokeWidth} strokeLinejoin="round" strokeLinecap="round">
                    {result.glyphs.map((contours,gi)=>(
                      <path key={gi} d={contoursToSvgPath(contours.map(poly=>roundPts(poly,decimals)))} />
                    ))}
                  </g>
                </svg>
              ) : (
                <div className="text-sm text-neutral-500">Type some text.</div>
              )}
            </div>
          </div>

          <div className="rounded-2xl bg-white shadow p-3">
            <div className="flex items-center justify-between mb-2">
              <div className="font-medium">Python list (copy/paste)</div>
              <button onClick={()=>{try{textAreaRef.current?.select();document.execCommand&&document.execCommand('copy');}catch{}}} className="text-xs px-2 py-1 rounded-lg border">Select all</button>
            </div>
            <textarea ref={textAreaRef} value={pythonText} readOnly className="w-full h-56 font-mono text-xs border rounded-xl p-2" spellCheck={false} />
            <div className="text-xs text-neutral-600 mt-2">
              Format: {groupAs==="glyphs"?"[glyph][contour][[x,y]]":"[contour][[x,y]]"} · rounded to {decimals} dp.
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<TextToPointsApp />);
    </script>
  </body>
</html>
